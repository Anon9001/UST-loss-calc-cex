import ccxt
import sys
import csv
import requests
import json
import re
from operator import itemgetter
import time
import datetime

#### Global Vars

# A few weeks before UST was created.  Used to start the time on when we get transactions on some exchanges
ust_create_time = 1604192461000
ms_in_month = 1000 * 60 * 60 * 24 * 30
# Transactions start time.  always start with 0
start_times = [0]
# Conversion rate from anchor ust to ust.  used to figure out the balance of someone's account
anchor_conversion_rate = 1.263


# After this date we can no longer count UST as 1 to 1 so when we sell / buy from / to UST to non-stables on defi then we flag the account
depeg_timestamp = 1651935577000

####### Support functions
def takeTimestamp(elem):
    return elem['timestamp']

## Gets from deposit address from the terra blockchain from a transaction provided by a CEX
def transactionToFromAddress(tx):
    url = 'https://columbus-fcd.terra.dev/v1/tx/'+tx
    rawResponse = requests.get(url)
    res = json.loads(rawResponse.content)
    return res['tx']['value']['msg'][0]['value']['from_address']

## Get trades using CCTX functions.  symbol: (i.e "UST/USDC"), exchange: object created from keys specified by user
def get_trades(symbol, exchange):
    since = 0
    all_orders = []
    from_id = 'abc123'  # all ids are strings
    while since < exchange.milliseconds ():
        limit = 1000
        params = {
            'from_id': from_id,  # exchange-specific non-unified parameter name
        }
        orders = exchange.fetch_my_trades(symbol, since, limit, params)
        if len(orders):
            from_id = orders[len(orders) - 1]['id']
            all_orders += orders
            # TODO TAKE this break if statment out, used so testing is easier
            #if len(all_orders) > 2000:
            #    break
        else:
            break
    return all_orders

def get_trades_kraken(symbol, exchange):
    exchange.rateLimit = 10000
    all_orders = {}
    offset = 0
    while True:
        trades = exchange.fetch_my_trades(symbol=None, since=None, limit=None, params={'ofs': offset})
        if len(trades) < 1:
            break
        else:
            for curOrder in trades:
                if "UST" in curOrder['symbol']:
                    all_orders[curOrder['id']] = curOrder
            offset += len(trades)
    return all_orders.values()

## Get trades using CCTX functions.  symbol: (i.e "UST/USDC"), exchange: object created from keys specified by user
def get_trades_coinbase(symbol, exchange):
    since = 0
    all_orders = []
    params = {}
    while since < exchange.milliseconds ():
        limit = 1000
        orders = exchange.fetch_my_trades(symbol, since, limit, params)
        if exchange.last_response_headers._store.get('cb-after'):
            params= {'after': exchange.last_response_headers._store['cb-after'][1]}
        if len(orders):
            all_orders += orders
        else:
            break
    return all_orders


#special binance version of get_trades since binance behavior is different
def get_trades_binance(symbol, exchange):
    since = 0
    all_orders = dict()
    from_id = 0
    while since < exchange.milliseconds ():
        limit = 1000
        params = {
            'fromId': from_id,  # exchange-specific non-unified parameter name
        }
        if from_id == 0:
            params = {}
        orders = exchange.fetch_my_trades(symbol, since, limit, params)
        from_id = orders[len(orders) - 1]['id']
        for curOrder in orders:
            all_orders[curOrder['id']] = curOrder
        if len(orders) <= 1:
            break
    return all_orders.values()

def get_trades_kucoin(symbol, exchange):
    since = ust_create_time
    all_orders = dict()
    while since < exchange.milliseconds ():
        limit = 500
        params = {}
        orders = exchange.fetch_my_trades(since = since, limit = limit, params = params)
        if len(orders) >= 499:
            since = orders[len(orders) - 1]['timestamp']
        else:
            since += (1000 * 60 * 60 * 24 * 7) - 10000
        for curOrder in orders:
            if "UST" in curOrder['symbol']:
                if curOrder['side'] == "buy":
                    curOrder['side'] = "sell"
                else:
                    curOrder['side'] = "buy"
                cost = curOrder['cost']
                amount = curOrder['amount']
                curOrder['cost'] = amount
                curOrder['amount'] = cost
                all_orders[curOrder['id']] = curOrder
    return all_orders.values()

## Gets all exchange keys and types from input.csv and returns a dictionary of unique user ids to array of exchanges
def get_exchange_args():
    f = open("input.csv", "r")
    next(f)
    usersToExchanges = []
    for x in f:
        curDatExchange = x.split(",")
        if len(curDatExchange)>0 and len(curDatExchange[0]) > 0:
            uuid = curDatExchange[0]
            exchangeUUID = curDatExchange[1].strip(' \t\n\r')
            exchangeArgs = {'enableRateLimit': True}

            if exchangeUUID == "terra":
                exchangeArgs['terraAddress'] = curDatExchange[2].strip(' \t\n\r')
            

            if len(curDatExchange)>2 and len(curDatExchange[2]) > 0:
                exchangeArgs['apiKey'] = curDatExchange[2].strip(' \t\n\r')
            if len(curDatExchange)>3 and len(curDatExchange[3]) > 0:
                exchangeArgs['secret'] = curDatExchange[3].strip(' \t\n\r')
            if len(curDatExchange)>4 and len(curDatExchange[4]) > 0:
                exchangeArgs['id'] = curDatExchange[4].strip(' \t\n\r')
            if len(curDatExchange)>5 and len(curDatExchange[5].rstrip('\n')) > 0:
                exchangeArgs['password'] = curDatExchange[5].rstrip('\n').strip(' \t\n\r')
            usersToExchanges += [[uuid, [exchangeUUID, exchangeArgs]]]

    return usersToExchanges

def createExchange(singleEntry):
    exchangeUUID = singleEntry[0]
    exchangeArgs = singleEntry[1]

    try:
        exchange_class = getattr(ccxt, exchangeUUID)
        exchange = exchange_class(exchangeArgs)
        return exchange
    except Exception as e:
        print("Error making exchange getting data for user: "+uuid+" with args:"+"exchangeData"+" error:"+str(e))
        return none

### All functions supporting terra blockchain info gathering start
## Gets all transactions
def getAllTransactions(address):
    currentOffset = 0
    limit = 100
    allTransactions = {}
    while True:
        url = 'https://columbus-fcd.terra.dev/v1/txs?offset='+str(currentOffset)+'&limit='+str(limit)+'&account=' + address
        rawResponse = requests.get(url)
        res = json.loads(rawResponse.content)['txs']
        if res == []:
            break
        for curTrans in res:
            curTrans['height'] = int(curTrans['height'])
            allTransactions[curTrans['txhash']] = curTrans
        currentOffset += limit
    allTrans = allTransactions.values()
    allTrans = sorted(allTrans, key=itemgetter('height'), reverse=True)
    return allTrans

## Gets balance of UST, assumes balance of 0 for aUST
def getCurrentBalance(address):
    url = 'https://columbus-lcd.terra.dev/cosmos/bank/v1beta1/balances/' + address
    rawResponse = requests.get(url)
    res = json.loads(rawResponse.content)['balances']
    curUSTBalance = 0
    curAnchorBalance = 0
    for curBalance in res:
        if curBalance['denom'] == "uusd":
            curUSTBalance = curBalance['amount']

    return float(curUSTBalance)/1000000 + (float(curAnchorBalance)/1000000 * anchor_conversion_rate)


def whContractSend(msg, cAddr):
    if 'send' in msg['value']['execute_msg']:
        if 'contract' in msg['value']['execute_msg']['send']:
            if msg['value']['execute_msg']['send']['contract'] == cAddr:
                return True
    return False

#def getBalancesAtBlock(blockHeight, transactions, balances, address):
def get_trades_defi(transactions, address):

#curTrade['timestamp'] > chain_halt_time and curTrade['side'] == 'buy' 
#                for curTrade in all_sells:
#                    total_UST_sold += curTrade['amount']
#                    total_USD_recived += curTrade['cost']
#
#                for curTrade in depeged_buys:
#                    total_UST_bought += curTrade['cost']
#                    total_USD_used += curTrade['amount']

    scanRequested = False
    buyUSTContract = ["terra1skjr69exm6v8zellgjpaa2emhwutrk5a6dz7dd", "terra1xj49zyqrwpv5k928jwfpfy2ha668nwdgkwlrg3", "terra1m6ywlgn6wrjuagcmmezzz2a029gtldhey5k552","terra14z56l0fp2lsf86zy3hty2z47ezkhnthtr9yq76", "terra1wmaty65yt7mjw6fjfymkd9zsm6atsq82d9arcd"]
    sellUSTContract = ["terra1szt6cq52akhmzcqw5jhkw3tvdjtl4kvyk3zkhx", "terra1x0ulpvp6m46c5j7t40nj24mjp900954ys2jsnu", "terra1qr2k6yjjd5p2kaewqvg93ag74k6gyjr7re37fs"]
    allTrans = []
    for curTrans in transactions:
        msg = curTrans['tx']['value']['msg'][0]
        # Using Anchor contract
        timestamp = datetime.datetime.strptime(curTrans['timestamp'], "%Y-%m-%dT%H:%M:%SZ").timestamp()*1000
        # Flagged - manual review because swaps between UST and non stables occured after depeg
        outTrans = {'timestamp': timestamp, 'hash':curTrans['txhash'], 'side': 'n/a', 'amount': 0, 'cost': 0, 'flagged': False}
        if msg['type'] == "bank/MsgSend":
            if msg['value']['to_address'] == address and msg['value']['from_address'] == address and curTrans['tx']['value']['memo'] == "collect my info urg":
                scanRequested = True
        # Using terra swap contract to real stable coin
        elif msg['type'] == "wasm/MsgExecuteContract":
            timestampOfUSTPurchase = datetime.datetime.strptime(curTrans['timestamp'], "%Y-%m-%dT%H:%M:%SZ").timestamp()*1000
            transactionId = curTrans['txhash']
            #if there is an error in the contract, just continue
            if 'code' in curTrans:
                continue
            if msg['value']['contract'] in buyUSTContract:
                outTrans['side'] = 'buy'
                if msg['value']['contract'] == buyUSTContract[0] and whContractSend(msg, "terra1szt6cq52akhmzcqw5jhkw3tvdjtl4kvyk3zkhx"):
                    # UST bought
                    outTrans['cost'] = float(curTrans['logs'][0]['events'][6]['attributes'][12]['value'])/1000000
                    # Stablecoins spent
                    outTrans['amount'] = float(curTrans['logs'][0]['events'][6]['attributes'][11]['value'])/100000000
                elif msg['value']['contract'] == buyUSTContract[1] and whContractSend(msg, "terra1l7xu2rl3c7qmtx3r5sd2tz25glf6jh8ul7aag7"):
                    outTrans['cost'] = float(curTrans['logs'][0]['events'][6]['attributes'][12]['value'])/1000000
                    outTrans['amount'] = float(curTrans['logs'][0]['events'][6]['attributes'][11]['value'])/1000000
# buy UST with luna
                elif msg['value']['contract'] == buyUSTContract[2] and curTrans['logs'][0]['events'][6]['attributes'][4]['value'] == "uluna" and curTrans['logs'][0]['events'][6]['attributes'][5]['value'] == "uusd": 
                    if timestamp > depeg_timestamp:
                        outTrans['flagged'] = True
                    outTrans['cost'] = float(curTrans['logs'][0]['events'][6]['attributes'][7]['value'])/1000000
                    outTrans['amount'] = float(curTrans['logs'][0]['events'][6]['attributes'][7]['value'])/1000000
                elif msg['value']['contract'] == buyUSTContract[3]: # This should have 4 events in here.  anc buy, anc sell, anc + ust buy, and+ust sell
                    if timestamp > depeg_timestamp:
                        outTrans['flagged'] = True
#buy UST with ANC
                    if whContractSend(msg, "terra1qr2k6yjjd5p2kaewqvg93ag74k6gyjr7re37fs"):
                        outTrans['cost'] = float(curTrans['logs'][0]['events'][6]['attributes'][12]['value'])/1000000
                        outTrans['amount'] = float(curTrans['logs'][0]['events'][6]['attributes'][12]['value'])/1000000
# staking ANC or selling UST for stake
                    elif 'increase_allowance' in msg['value']['execute_msg']: # it's a sell
                        outTrans['side'] = 'sell'
                        outTrans['cost'] = float(curTrans['logs'][1]['events'][5]['attributes'][2]['value'].removesuffix('uusd'))/1000000
                        outTrans['amount'] = float(curTrans['logs'][1]['events'][5]['attributes'][2]['value'].removesuffix('uusd'))/1000000
# unstake ANC / buy UST                        
                elif msg['value']['contract'] == buyUSTContract[4] and whContractSend(msg, "terra1qr2k6yjjd5p2kaewqvg93ag74k6gyjr7re37fs"):
                    if timestamp > depeg_timestamp:
                        outTrans['flagged'] = True
                    outTrans['cost'] = float(curTrans['logs'][0]['events'][5]['attributes'][2]['value'].removesuffix('uusd'))/1000000
                    outTrans['amount'] = float(curTrans['logs'][0]['events'][5]['attributes'][2]['value'].removesuffix('uusd'))/1000000
                else:
                    continue
            elif msg['value']['contract'] in sellUSTContract:
                outTrans['side'] = 'sell'
# Sell UST for BUSD
                if msg['value']['contract'] == sellUSTContract[0] and 'swap' in msg['value']['execute_msg']:
                    # Amount of UST Sold
                    outTrans['amount'] = float(curTrans['logs'][0]['events'][6]['attributes'][6]['value'])/1000000
                    # Amount of USD recived
                    outTrans['cost'] = float(curTrans['logs'][0]['events'][6]['attributes'][7]['value'])/100000000
# Sell UST for USDC
                elif msg['value']['contract'] == sellUSTContract[1] and 'swap' in msg['value']['execute_msg']:
                    outTrans['amount'] = float(curTrans['logs'][0]['events'][6]['attributes'][6]['value'])/1000000
                    outTrans['cost'] = float(curTrans['logs'][0]['events'][6]['attributes'][7]['value'])/1000000
# sell UST and recive ANC
                elif msg['value']['contract'] == sellUSTContract[2] and 'swap' in msg['value']['execute_msg']:
                    outTrans['amount'] = float(curTrans['logs'][0]['events'][6]['attributes'][6]['value'])/1000000
                    outTrans['cost'] = float(curTrans['logs'][0]['events'][6]['attributes'][6]['value'])/1000000
                else:
                    continue
            else:
                continue
            allTrans.append(outTrans)

    if scanRequested == False:
        print("defi address:"+str(address)+" does not have memo collect my info urg ")
        return []
    return allTrans 

### Terra suppport functions end


# Gets UST balance on exchange, UST sold, USD equlivant recived on stablecoins, UST bought / USD used to buy UST after depeg time
def get_losses(exchange, exchangeUUID):

    fromTradeSymbol = ['UST', 'USTC']
    toTradeSymbol = ['USD', 'USDC', 'USDT', 'DAI', 'BUSD', 'TUSD', 'USDD', 'GUSD', 'MIM']

    # UST balance
    balance = 0
    try:
        curBalance = exchange.fetch_balance()
        if curBalance['total']['USTC'] != 0:
            balance = curBalance['total']['USTC']

        if curBalance['total']['UST'] != 0:
            balance = curBalance['total']['UST']
    except Exception as e:
        pass

    # When selling UST
    total_UST_sold = 0
    total_USD_recived = 0

    # When buying UST
    total_UST_bought = 0
    total_USD_used = 0
    #markets = exchange.load_markets()
    #print("markets are: "+str(markets))
    trades = []
    for curFromTradeSymbol in fromTradeSymbol:
        for curToTradeSymbol in toTradeSymbol:
            symbol = curFromTradeSymbol + "/" + curToTradeSymbol
            try:
                if exchangeUUID == 'binance':
                    trades += get_trades_binance(symbol, exchange)
                elif exchangeUUID == 'kucoin':
                    trades += get_trades_kucoin(symbol, exchange)
                # Not tested for coinbase prime or coinbase
                elif exchangeUUID == 'coinbasepro' or exchangeUUID == 'coinbaseprime' or exchangeUUID == 'coinbase':
                    trades += get_trades_coinbase(symbol, exchange)
                elif exchangeUUID == 'kraken':
                    trades += get_trades_kraken(symbol, exchange)
                else:
                    trades += get_trades(symbol, exchange)
                

                #only count buys after the first chain halt time in report as depeged / not guarenteed 1 UST to 1 USD purchases
                #depeged_buys = list(filter(lambda curTrade: (curTrade['timestamp'] > chain_halt_time and curTrade['side'] == 'buy' ), trades))
                #all_sells = list(filter(lambda curTrade: (curTrade['timestamp'] > depeg_timestamp and curTrade['side'] == 'sell' ), trades))
                #depeged_buys.sort(key=takeTimestamp)
                #all_sells.sort(key=takeTimestamp)
                '''for curTrade in all_sells:
                    total_UST_sold += curTrade['amount']
                    total_USD_recived += curTrade['cost']

                for curTrade in depeged_buys:
                    total_UST_bought += curTrade['cost']
                    total_USD_used += curTrade['amount']
                '''
                # Only do kucoin once because it's not using symbol
                if exchangeUUID == 'kucoin' or exchangeUUID == 'kraken':
                    break
            except Exception as e:
                #print("exception e:"+str(e))
                pass
        # Only do kucoin once because it's not using symbol
        if exchangeUUID == 'kucoin' or exchangeUUID == 'kraken':
            break
    #return {'balance':balance, 'sell_ust': total_UST_sold, 'sell_usd': total_USD_recived, 'buy_ust':total_UST_bought, 'buy_usd': total_USD_used}
    trades.sort(key=takeTimestamp)
    return [balance, trades]

def print_usage_exit():
    print("USAGE: python3 run.python <As many optional timestamps to divide up totals>")
    print("Example: python3 run.python 1651935577000 1652407129000")
    print("1651935577000 is the timestamp of when Do Kwon says the depeg occured, 1652407129000 is the time at which the chain halted")
    sys.exit()

def avgPrice(ustAmt, usdRecovered):
    avgPriceForUST = 0
    try:
        avgPriceForUST = usdRecovered / ustAmt
    except Exception as e:
        pass
    return avgPriceForUST

# Get user specified args
    #print_usage_exit()


for i in range(1, len(sys.argv)):
    start_times.append(int(sys.argv[i]))

users = get_exchange_args()
userData = dict()
for curUser in users:
    curUserData = {'cex': [], 'defi': []}
    if curUser[0] in userData:
        curUserData = userData[curUser[0]]
    
    if curUser[1][0] == "terra":
        if 'terraAddresses' not in curUserData:
            curUserData['terraAddresses'] = []
        allAddresses = curUserData['terraAddresses'] + [curUser[1][1]['terraAddress']]
        curUserData['terraAddresses'] = allAddresses
    else:
        exchange = createExchange(curUser[1])
        curResult = get_losses(exchange, curUser[1][0])

        curUserData['cex'] = curUserData['cex'] + curResult[1] #save trades
        if 'balance' not in curUserData:
            curUserData['balance'] = 0
        curUserData['balance'] = curUserData['balance'] + curResult[0] # save balance
    
    userData[curUser[0]] = curUserData

# More title labels will be added depending on user inputted args
output = [['user name/id','0 Total Balance UST', '0 Total UST Sold', '0 Total usd recovered', '0 Total UST Purchased', '0 Total usd paid for UST']]
for userName in userData:
    if 'terraAddresses' in userData[userName]:
        for curAddress in userData[userName]['terraAddresses']:
            unformattedTrans = getAllTransactions(curAddress)
            curBalance = getCurrentBalance(curAddress)  # 0 is UST balance, 1 is aUST (but aust is currently non functional)
            if 'balance' not in userData[userName]:
                userData[userName]['balance'] = 0
            userData[userName]['balance'] = userData[userName]['balance'] + curBalance # save balance

            defiTrans = get_trades_defi(unformattedTrans, curAddress)
            userData[userName]['defi'] = userData[userName]['defi'] + defiTrans

columnTitle = ['username/id', 'total current balance of UST']
# create output title
for curTime in start_times:
    columnTitle += [str(curTime) + ' Total UST Sold', str(curTime) + ' Total usd recovered', str(curTime) + ' Total UST Purchased', str(curTime) + ' Total usd paid for UST']

allOutput = [columnTitle]
# create output string for each user
for userName in userData:
    curUserOutput = [userName, userData[userName]['balance']]
    cexTrades = userData[userName]['cex']
    cexTrades.sort(key=takeTimestamp)

    defiTrades = userData[userName]['defi']
    defiTrades.sort(key=takeTimestamp)
    cexIndex = 0
    defiIndex = 0
    for startTimesIndex in range(len(start_times)):
        ustSold = 0
        usdRecovered = 0
        ustPurchased = 0
        usdSpent = 0

        curTime = start_times[startTimesIndex]
        if startTimesIndex == len(start_times) - 1:
            #reached the end
            while cexIndex < len(cexTrades):
                curTrade = cexTrades[cexIndex]
                cexIndex += 1
                if curTrade['side'] == 'sell':
                    ustSold += curTrade['amount']
                    usdRecovered += curTrade['cost']
                elif curTrade['side'] == 'buy':
                    ustPurchased += curTrade['cost']
                    usdSpent += curTrade['amount']

            while defiIndex < len(defiTrades):
                curTrade = defiTrades[defiIndex]
                defiIndex += 1
                if curTrade['side'] == 'sell':
                    ustSold += curTrade['amount']
                    usdRecovered += curTrade['cost']
                elif curTrade['side'] == 'buy':
                    ustPurchased += curTrade['cost']
                    usdSpent += curTrade['amount']
        else:
            curEndTime = start_times[startTimesIndex + 1]
            while cexIndex < len(cexTrades) and cexTrades[cexIndex]['timestamp'] <= curEndTime:
                curTrade = cexTrades[cexIndex]
                cexIndex += 1
                if curTrade['side'] == 'sell':
                    ustSold += curTrade['amount']
                    usdRecovered += curTrade['cost']
                elif curTrade['side'] == 'buy':
                    ustPurchased += curTrade['cost']
                    usdSpent += curTrade['amount']

            while defiIndex < len(defiTrades) and defiTrades[defiIndex]['timestamp'] <= curEndTime:
                curTrade = defiTrades[defiIndex]
                defiIndex += 1
                if curTrade['side'] == 'sell':
                    ustSold += curTrade['amount']
                    usdRecovered += curTrade['cost']
                elif curTrade['side'] == 'buy':
                    ustPurchased += curTrade['cost']
                    usdSpent += curTrade['amount']

        curUserOutput += [ustSold, usdRecovered, ustPurchased, usdSpent]
    allOutput += [curUserOutput]

import csv

with open("output.csv", "w", newline="") as f:
    writer = csv.writer(f)
    writer.writerows(allOutput)



